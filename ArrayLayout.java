/** File: ArrayLayout.java */

package cvt2mae;

import java.lang.String;

/** 
 * This class specifies vendor and user defined Array Layouts.
 * Cvt2Mae stores array layouts in a subdirectory called  "/ArrayLayouts"
 * as *.alo files.
 * <P>
 * This work was produced by Peter Lemkin of the National Cancer
 * Institute, an agency of the United States Government.  As a work of
 * the United States Government there is no associated copyright.  It is
 * offered as open source software under the Mozilla Public License
 * (version 1.1) subject to the limitations noted in the accompanying
 * LEGAL file.
 *<P>
 * 
 * @author P. Lemkin (NCI), G. Thornwall (SAIC), B. Stephens(SAIC), NCI-Frederick, Frederick, MD
 * @version $Date: 2005/10/20 11:45:56 $ $Revision: 1.6 $ 
 * @see <A HREF="http://maexplorer.sourceforge.org/">MAExplorer Home</A>
 */


public class ArrayLayout
{
  /**  used in generating alNbrs' */
  static int
    masterNbr= 0;              
  /** *.alo file name */
  public String
    aloFileName;               
  /** chip vendor or manufacture making the chip */
  public String
    vendor;                    
  /** unique vendor's name or part number for chip */
  public String
    layoutName;                
  /** species where genes came from on chip */
  public String
    species;                  
  /** [TODO] add to constuctors and data? */
  public String
    tissue;                   
  /** [TODO] add to constuctors and data?  */
  public String
    strain;                   
  /** quantification tool used to segment spots */
  public String
    quantTool;                 
  /** Used with UniGene */
  public String
    UniGeneSpeciesPrefix;     
  /** if not null, skip lines with this as 1st token */
  public String
    commentToken; 
  /** initial keyword if any for chip */
  public String
    initialKeyword;   
  /** unique ArrayLayout instance number */
  public int
    alNbr;                     
  /** maximum complete duplicate Fields of grids on chip */
  public int
    maxFields;                  
  /** number of grids in one field */
  public int
    nGridsPerField;          
  /** number of rows of spots per grid */
  public int
    rowsPerGrid;              
  /** number of columns of spots per grid */
  public int
    colsPerGrid;               
  /** max number of data rows - i.e. clones in array */
  public int
    maxRowsExpected;               
  /** expected number of tokens for this layout */
  public int
    expectedNbrTokens;  
  /** optional row in user FieldQ file where expect samples list */
  public int
    rowWithSamples;           
  /** row in user FieldQ file where expect Fields list */
  public int
    rowWithFields;            
  /** row in user FieldQ file where expect Data */
  public int
    rowWithData;          
  /** optional row in user FieldG separate GIPO file where expect Fields list */
  public int
    rowWithSepGIPOFields;            
  /** optional row in user FieldG separate GIPO file where expect Data */
  public int
    rowWithSepGIPOData;         
  /** flag: If changes made with arrays thru editing, array must be saved if true */
  public boolean
    saveArrayFlag;	       
  /** flag: true if file contains multiple data sets */
  public boolean
    hasMultDatasetsFlag;        
  /** flag: true if specify pseudo array geometry from number of spots in 
   * maxRowsExpected */
  public boolean
    specifyGeometryByNbrSpotsFlag;
  /** flag: pseudo array layout else exact (F,G,R,C) */ 
  public boolean
    pseudoArrayFlag;           
  /** flag: data is Cy3/Cy5 type fluorescent ratio data */
  public boolean
    useRatioDataFlag;
  /** flag: Set if .quant data has negative intensity values otherwise 
   * it clips the negative values to 0.0 (eg. AFFY) */ 
  public boolean
    allowNegQuantDataFlag;          
  /** flag: check and edit Samples and Field names data before use.
   * This is for handling the bad Affy fields data generated by the old Affy
   * software.
   */
  public boolean
    chkAndEditFieldNamesFlag;    
  /** flag: has background intensity data */ 
  public boolean
    hasBkgrdDataFlag;    
  /** flag: has actual quant XY coordinates data */ 
  public boolean
    hasQuantXYcoordsFlag;         
  /** bit subsets of properties from mcd.PROP_xxxx */
  public long
    bitProps;   
  /** # of desired fields in field mapping */
  public int
    nDesiredFields;           
  /** A list of desired fields we extract from table header. The rest are ignored.
   * This list of mapped fields will be analyzed during processing.
   * An entry is
   * <PRE>
   *  "< MAE field name >:< user field name >" 
   </PRE>
   * Note: If there is a leading '*', then the field is an instance of a sample 
   * field and may be repeated multiple times and is used for extracting data into 
   * separate .quant files.
   */
  public String
    desiredFields[];           
  /** Optional GEO Platform ID */    
  public String
    geoPlatformID;
  
  /** field map of internal (MAE) to external (User) Table Fields */
  public FieldMap
    fieldMap;                  
  /** Table equivalent of desiredFields[] */
  public FileTable
    mapTbl;                    
  /** for newline, Mac= "\r" Sun ="\n" PC= "\r\n" */   
  String
    newline;
  
  
  /**
   * ArrayLayout() - constructor for Array Layouts.
   * @param aloFileName is the Array Layout file name
   * @param vendor is the Array Layout vendor name
   * @param layoutName is the Array Layout name
   * @param species is the species name
   * @param quantTool is the quantification tool used to segment spots
   * @param UniGeneSpeciesPrefix is used with UniGene 
   * @param commentToken for comments
   * @param initialKeyword initial keyword if any for chip
   * @param hasMultDatasetsFlag flag: true if file contains multiple data sets 
   * @param specifyGeometryByNbrSpotsFlag flag: true if specify pseudo array geometry from number of spots in maxRowsExpected
   * @param maxFields maximum number of fields
   * @param nGridsPerField number of grids in one field 
   * @param rowsPerGrid number of rows of spots per grid 
   * @param colsPerGrid number of columns of spots per grid
   * @param maxRowsExpected max number of data rows - i.e. clones in array
   * @param expectedNbrTokens expected number of tokens for this layout
   * @param rowWithSamples optional row in user FieldQ file where expect samples list
   * @param rowWithFields row in user FieldQ file where expect Fields list
   * @param rowWithData row in user FieldQ file where expect Data to start
   * @param rowWithSepGIPOFields optional row in user FieldG separate GIPO file where expect Fields list
   * @param rowWithSepGIPOData optional row in user FieldG separate GIPO file where expect Data
   * @param pseudoArrayFlag flag: pseudo array layout else exact (F,G,R,C)
   * @param useRatioDataFlag flag: data is Cy3/Cy5 type fluorescent ratio data
   * @param allowNegQuantDataFlag it clips the negative values to 0.0 (eg. AFFY)
   * @param chkAndEditFieldNamesFlag flag: check and edit Samples and Field names data before use.
   * @param hasBkgrdDataFlag  flag: has background intensity data
   * @param hasQuantXYcoordsFlag flag: has actual quant XY coordinates data
   * @param bitProps bit subsets of properties from mcd.PROP_xxxx
   * @param desiredFields[] This list of mapped fields will be analyzed during processing
   * @param geoPlatformID optional GEO Platform ID
   * @see FileTable#cvtStrToTable
   * @see #buildMapTFentries
   * 
   */
  ArrayLayout(String aloFileName,
	            String vendor,
              String layoutName,
              String species,
              String quantTool,
              String UniGeneSpeciesPrefix,
              String commentToken,
              String initialKeyword,
              
              boolean hasMultDatasetsFlag,
              boolean specifyGeometryByNbrSpotsFlag,
              
              int maxFields,
              int nGridsPerField,
              int rowsPerGrid,
              int colsPerGrid,
              int maxRowsExpected,
              int expectedNbrTokens,
              
              int rowWithSamples,
              int rowWithFields,
              int rowWithData,
              int rowWithSepGIPOFields,
              int rowWithSepGIPOData,
              
              boolean pseudoArrayFlag,
              boolean useRatioDataFlag,
              boolean allowNegQuantDataFlag,
              boolean chkAndEditFieldNamesFlag,
              boolean hasBkgrdDataFlag,
              boolean hasQuantXYcoordsFlag,
              long bitProps,
              String desiredFields[],
              String geoPlatformID
              )
  { /* ArrayLayout */
    this.alNbr= ++masterNbr;        /* generate serial #s */
    
    String osName= System.getProperty("os.name");
    boolean isMacFlag= osName.equals("Mac OS");
    if(isMacFlag)
      newline= System.getProperty("line.separator");
    else
      newline= "\n";
    
    this.aloFileName= UtilCM.mapSpaceToMinus(aloFileName);
    this.vendor= vendor;
    this.layoutName= layoutName;
    this.species= species;
    this.quantTool= quantTool;
    this.UniGeneSpeciesPrefix= UniGeneSpeciesPrefix;
    this.commentToken= (commentToken==null) ? "" : commentToken;
    this.initialKeyword= (initialKeyword==null) ? "" : initialKeyword;
    
    saveArrayFlag= false;
    this.hasMultDatasetsFlag= hasMultDatasetsFlag;
    this.specifyGeometryByNbrSpotsFlag= specifyGeometryByNbrSpotsFlag;
    this.allowNegQuantDataFlag= allowNegQuantDataFlag;
    this.chkAndEditFieldNamesFlag= chkAndEditFieldNamesFlag;
    this.hasBkgrdDataFlag= hasBkgrdDataFlag;
    this.hasQuantXYcoordsFlag= hasQuantXYcoordsFlag;
    
    this.maxFields= maxFields;
    this.nGridsPerField= nGridsPerField;
    this.rowsPerGrid= rowsPerGrid;
    this.colsPerGrid= colsPerGrid;
    this.maxRowsExpected= maxRowsExpected;
    this.expectedNbrTokens= expectedNbrTokens;
    
    this.rowWithSamples= rowWithSamples;
    this.rowWithFields= rowWithFields;
    this.rowWithData= rowWithData;
    
    this.rowWithSepGIPOFields= rowWithSepGIPOFields;
    this.rowWithSepGIPOData= rowWithSepGIPOData;
    
    this.pseudoArrayFlag= pseudoArrayFlag;
    this.useRatioDataFlag= useRatioDataFlag;
    
    this.bitProps= bitProps;     /* bit subsets of properties from mcd.PROP_xxxx */
    
    this.geoPlatformID= geoPlatformID;
    
    /* Create map entries */
    this.fieldMap= new FieldMap(layoutName+"-"+alNbr);   /* empty map */
    
    /* Save field data locally and then parse into fieldMap */
    this.desiredFields= desiredFields;
    nDesiredFields= 0;
    mapTbl= null;                 /* clear table */
    String sData= "";
    
    /* Create empty Table with fields but no rows of data */
    mapTbl= new FileTable("Map Table",0,0);
    
    if(desiredFields!=null)
    { /* convert def[] string array to a table */
      for(int i=0;i<desiredFields.length;i++)
        if(desiredFields[i]!=null && desiredFields[i].length()>0)
        { /* build string to parse as a Table */
          nDesiredFields++;           /* count non-null entries */
          sData += (desiredFields[i] + newline);
        }
      
     /* Convert tab-delim String data to Table data structure.
      * Set up the table data structures:
      *  (tRows, tCols, tFields[], tData[][]).
     */
      if(!mapTbl.cvtStrToTable(sData))
        mapTbl= null;
      else
      { /* Build mapTF DB if mapTbl and fieldMap exists */
        buildMapTFentries();
      }
    } /* convert def[] string array to a table */
    /*
    if(Cvt2Mae.DBUG_FLAG)
      System.out.println("AL-AL mapTbl="+mapTbl+"\n fieldMap="+fieldMap+
                         "\n nDesiredFields="+nDesiredFields+
                         "\n sData='"+sData+"'");
    */
  } /* ArrayLayout */
  
  
  /**
   * buildMapTFentries() - build mapTF DB if mapTbl and fieldMap exists
   * @return true if mapTbl and fieldMap exists
   * @see FieldMap#addEntry
   * @see FieldMap#clearMap
   * @see FileTable#lookupFieldIdx
   *
   */
  public boolean buildMapTFentries()
  { /* buildMapTFentries */
    /*
    if(Cvt2Mae.DBUG_FLAG)
      System.out.println("AL-BMTFE.1 mapTbl="+mapTbl+" fieldMap="+fieldMap);
       */
    
    if(mapTbl==null || fieldMap==null)
      return(false);
    
    fieldMap.clearMap();           /* clear out the map */
    
    int
      idxTableName= mapTbl.lookupFieldIdx("Table name"),
      idxMaeField= mapTbl.lookupFieldIdx("MAE field"),
     idxUserField= mapTbl.lookupFieldIdx("User field");
    /*
    if(Cvt2Mae.DBUG_FLAG)
      System.out.println("AL-BMTFE.2 idxTableName="+idxTableName+
                         " idxMaeField="+idxMaeField+
                         " idxUserField="+idxUserField);
    */
    if(idxTableName==-1 || idxMaeField==-1 || idxUserField==-1)
      return(false);
    
    for(int r= 0;r<mapTbl.tRows;r++)
    { /* add entries to fieldMap list */
      boolean repeatFlag= false;
      String rowData[]= mapTbl.tData[r],
      mT= rowData[idxTableName],
      mF= rowData[idxMaeField];
      if(mT==null)
        continue;                /* ignore null entires */
      if(mT.startsWith("*"))
      { /* mark this '*' map as repetitive */
        mT= mT.substring(1);  /* remove '*' but mark as repeat */
        repeatFlag= true;
      }
      String
        uT= mT,
        uF= rowData[idxUserField];
      
      fieldMap.addEntry(mT,mF,uT,uF,repeatFlag);
    }
    
    /*
    if(Cvt2Mae.DBUG_FLAG)
      System.out.println("AL-BMTFE.3\n"+fieldMap.toString());
    */
    
    return(true);
  } /* buildMapTFentries */
  
  
  /**
   * toString() - make prettyprint string for Array Layout.
   * @return prettyprint string for Array Layout
   */
  public String toString()
  { /* toString */
    String s= "ArrayLayout["+alNbr+"]";
    
    s += "aloFileName='"+aloFileName+"'";
    s += "vendor='"+vendor+"'";
    s += newline + " layoutName='"+ layoutName+"'";
    s += newline + " species='"+ species+"'";
    s += newline + " quantTool='"+ quantTool+"'";
    s += newline + " UniGeneSpeciesPrefix="+ UniGeneSpeciesPrefix;
    
    s += newline + " hasMultDatasetsFlag="+hasMultDatasetsFlag;
    s += newline + " specifyGeometryByNbrSpotsFlag="+
    specifyGeometryByNbrSpotsFlag;
    s += newline + " allowNegQuantDataFlag="+allowNegQuantDataFlag;
    s += newline + " chkAndEditFieldNamesFlag="+chkAndEditFieldNamesFlag;
    s += newline + " hasBkgrdDataFlag="+hasBkgrdDataFlag;
    s += newline + " hasQuantXYcoordsFlag="+hasQuantXYcoordsFlag;
    
    s += newline + " maxFields="+ maxFields;
    s += newline + " nGridsPerField="+ nGridsPerField;
    s += newline + " rowsPerGrid="+ rowsPerGrid;
    s += newline + " colsPerGrid="+ colsPerGrid;
    s += newline + " maxRowsExpected="+ maxRowsExpected;
    
    s += newline + " expectedNbrTokens="+ expectedNbrTokens;
    s += newline + " pseudoArrayFlag="+ pseudoArrayFlag;
    s += newline + " useRatioDataFlag="+ useRatioDataFlag;
    
    s += newline + " rowWithSamples="+ rowWithSamples;
    s += newline + " rowWithFields="+ rowWithFields;
    s += newline + " rowWithData="+ rowWithData;
    
    s += newline + " rowWithSepGIPOFields="+ rowWithSepGIPOFields;
    s += newline + " rowWithSepGIPOData="+ rowWithSepGIPOData;
    
    s += newline + " commentToken='"+ initialKeyword+"'";
    s += newline + " initialKeyword='"+ commentToken+"'";
    s += newline + " geoPlatformID='"+ geoPlatformID+"'";
    
    s += newline + fieldMap.toString();

    return(s);
  } /* toString */
  
} /* end of ArrayLayout */


