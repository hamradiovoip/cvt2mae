/** File: MaeConfigData.java */

package cvt2mae;

import java.awt.*;
import java.util.*;
import java.io.*;
import java.awt.event.*;

/**
 * This class holds the state of the MAE data
 * and is used to write (and read) the MAExplorer Config. It also holds the
 * instances for the SamplesDB (msd) and .mae startup file database (msud).
 * Those classes have their own read and write to file methods. <BR>
 *<P>
 * An instance of MaeConfigData (as well as MaeSampleData and MaeStartupData)
 * should be created when the calling program first starts. The state
 * may be filled either by:
 * <PRE>
 *  1. the calling program stuffing the variables, <BR>
 *  2. the calling program calling an editor which will stuff the
 *     variables, or <BR>
 *  3. calling a readXXXX() method to read the variables from
 *     files. <BR>
 *</PRE>
 * All of the state variables have default values defined when the instance
 * is created. These should normally be overidden. <BR>
 *
 * The directory Tree may be checked and created as needed.
 * Typically, the entire project is written at one time, but
 * it may also be written separately (eg. if editing). <BR>
 *  <P>
 * This work was produced by Peter Lemkin of the National Cancer
 * Institute, an agency of the United States Government.  As a work of
 * the United States Government there is no associated copyright.  It is
 * offered as open source software under the Mozilla Public License
 * (version 1.1) subject to the limitations noted in the accompanying
 * LEGAL file.
 *<P>
 * @author P. Lemkin (NCI), G. Thornwall (SAIC), B. Stephens(SAIC), NCI-Frederick, Frederick, MD
 * @version $Date: 2005/10/20 11:45:56 $   $Revision: 1.16 $
 * @see <A HREF="http://maexplorer.sourceforge.org/">MAExplorer Home</A>
 */


public class MaeConfigData
{ /* MaeConfigData */
  /* link to global Cvt2Mae DB */
  public Cvt2Mae
   cvt;
  /** link to MAE samples data */
  public MaeSampleData
    msd;
  /** link to MAE startup file .mae (ie .mae file)*/
  public MaeStartupData
    msud;
  /** link to DataIO data */
  public DataIO
    dio;
  /** if true in step 2., do NOT allow step 3. May be set in EditLayout
   * for <User-defined>.
   */
  public boolean
    needToReAnalyzeFilesFlag= true;
  /** edit only 1 Layout window at a time */
  public boolean
    editMaePrjFilesFlag= true;
  /** user has edited chip layout */
  public boolean
    editedLayoutFlag= false;
  /** orig data file had mult. samples/mult. samples/mult. samples/mult. samples/mult. samples/file */
  public boolean
    hasMultDatasetsFlag= false;
  /** orig data file had mult. samples/file */
  public boolean
    hasSeparateGIPOandQuantFilesFlag= false;
  /** set true if gen. FGRC from # gene rows*/
  public boolean
    pseudoArrayFlag= false;
  /** is true while editing */
  public boolean
    beingEditedFlag= false;
  
  /** did an Edit Layout indicated by pressing Done */
  public boolean
    didEditALOflag= false;
  /** did an Assign GIPO indicated by pressing Done */
  public boolean
    didGIPOassignFlag= false;
  /** did an Assign Quant indicated by pressing Done */
  public boolean
    didQuantFlag= false;
  /** flag: that the Reanalyze button is active
   * (didEditALOflag && didGIPOassignFlag && didQuantFlag &&
   *  hasMultDatasetsFlag). So must edit all three to active it.
   */
  public boolean
    activeReanalyeButtonFlag= false;
  
  /** The default is that the GIPO is contained in the general source file, else
   * it is contained in a separate GIPO input file separateGIPOinputFile.
   * [TODO] if false, need to
   * write code to 1) get separate GIPO file name, 2) generate GIPO
   * after do separate "Assign GIPO fields" mapping.
   */
  public boolean
    gipoInGeneralSrcFileFlag= true;
  /** flag: set if selected <User-defined> layout */
  public boolean
    hasUserDefineChipsetFlag= false;
  
  /** flag: use the input tmp file to remap MAS5 data */
  public boolean
    useSrcTmpFileFlag;
  
  /** flag set if inputting paired chips (e.g. Affy U133A and U133B chips) */
  public boolean
    use2ndInputChipFileFlag;
  
  /** flag: check and edit Samples and Field names data before use.
   * This is for handling the bad Affy fields data generated by the old Affy
   * software.
   */
  public boolean
    chkAndEditFieldNamesFlag;
  /** for tracking special considerations */
  public String
    vendor;
  /** Array (vendor specified) layout name */
  public String
    layoutName;
  /** i.e. maePrjDir + "ArrayLayout/" */
  public String
    aloDir;
  /** current ArrayLayout file name */
  public String
    aloFileName;
  /** date when this program is run */
  public String
    date;
  /** geo platform id str */
  public String
    geoPlatformID= "";
  /** current field map */
  public FieldMap
    fm= null;
  /* Unigene Species names. [TODO] add rest of codes. */
  public String
    speciesList[]= {"Hs", "Mm", "At", "Bt", "Dr", "Hv",
                    "Os", "Rn", "Ta", "Xl", "Zm", "?"
                    };
  /* corresponding Species names. */
  public String
    speciesNames[]= {"Human", "Mouse", "?", "?", "?", "?",
                      "?", "?", "?", "?", "?", "?"
                    };
  public int
    nSpeciesList= speciesList.length;
  /** Bit properties of the current state */
  public long
    bitProps;
  /* --- Data that is Sample Dependent --- */
  /** if GIPO data in separate input file */
  public String
    separateGIPOinputFile= null;
  
  /** source file names w/ .ext if any*/
  public String
    srcFile[];
  /** tmp source file names to use in palce of srcFile if they are not NULL.
   * This is because we have already transformed the srcFile and need to 
   * use this for subsequent data input.
   */
  public String
    tmpSrcFile[];
  /** [0:nQuantFiles-1] full (destination output) .quant file path */
  public String
    quantDstFile[];
  /** [0:nQuantFiles-1] final (destination output) .quant file name */
  public String
    quantName[];
  /** [0:nQuantFiles-1] orig. quant file name*/
  public String
    quantNameOrig[];
  /** [0:nQuantFiles-1] project name */
  public String
    prjName[];
  /** [0:nQuantFiles-1] full sample names for cvt.inSamplesList */
  public String
    fullSampleName[];
  
  /** Field name for "Grid" in separate GIPO fields if used. */
  public String
    sepGipoGridName;
  /** Field name for "Row" in separate GIPO fields if used. */
  public String
    sepGipoRowName;
  /** Field name for "Col" in separate GIPO fields if used. */
  public String
    sepGipoColName;
  /** # of rows in separate GIPO fields if used. */
  public int
    nSepGIPOrows= 0;
  /** # of fields in separate GIPO fields if used. */
  public int
    nSepGIPOfields= 0;
  /** [0:nSepGIPOfields-1] field names in separate GIPO if used. */
  public String
    sepGIPOfields[];
  /** # of fields in separate GIPO fields actually used. I.e.
   * this is the number of sepGIPOfieldesUsed[] that are TRUE.
   */
  public int
    nSepGIPOfieldsUsed= 0;
  /** [0:nSepGIPOfields-1] flag set if include fields in separate GIPO when
   * merge data of (FieldG+FieldQ) in readData(). if used. */
  public boolean
    sepGIPOfieldsUsed[];
  /** [0:nQuantFiles-1] # of rows in file */
  public int
    linesInFile[];
  /** flags: [0:nQuantFiles-1] ONLY for ratio data, if swap cy3/cy5 */
  public boolean
    swapCy5Cy3DataFlag[];  
  
  /** [0:nQuantFiles-1] # source in file */
  public int
    quantSampleNbrInFile[];
  /** [0:nQuantFiles-1] field # in quantSrcFile[] where sample is
   *  found.  [Note] there may be several fields that belong to the
   *  sample indicated by '*' in ArrayLayout prefix. ]
   */
  public int
    quantSrcFieldNbr[];
  /** [0:nQuantFiles-1] src file where sample found */
  public String
    quantSrcFile[];
  /** [0:nQuantFiles-1] src file directory where samples are found */
  public String
    quantSrcDir[];
  
  /** # source files that hold Quant &GIPO data*/
  public int
    nSrcFiles;
  /** # raw src files thatmay hold mult .quants*/
  public int
    nRawFiles;
  /** # of samples and generated .quant files */
  public int
    nQuantFiles;
  /** set if using existing Prj dir */
  public String
    existingPrjDir;
  /** species, "Human", "Mouse", etc. */
  public String
    species;
  /** image quant program */
  public String
    imgAnalySoftware;
  /** if not "", is input file comment prefix*/
  public String
    commentToken;
  /** initial keyword if not "" */
  public String
    initialKeyword;
  /** system specific / or \ or :, etc */
  public String
    fileSep;
  /** startup directory */
  public String
    userDir;
  /** output project directory */
  public String
    maePrjDir;
  /** dirName or maePrjDir/Config */
  public String
    configDir;
  /** dirName or maePrjDir/Quant */
  public String
    quantDir;
  /** source data files directory */
  public String
    dirName;
  
  /** generic DB project name for all input array data. This defaults
   * to dirName, but may be overidden in * EditLayout and is then used
   * to update * all prjName[] entries.
   */
  public String
    dbPrjName= "";
  /** source file name w/o .ext each time.*/
  public String
    srcName;
  /** full SamplesDB.txt file path */
  public String
    samplesFile;
  /** SamplesDB-sn.txt file name */
  public String
    samplesName;
  /** GIPO file name */
  public String
    gipoName;
  /** full path of GIPO file  */
  public String
    gipoFile;
  /** MaeConfig-sn.txt file name */
  public String
    configName;
  /** full path of Config file */
  public String
    configFile;
  /** [TODO] maybe want to rename maeFile */
  public String
    startupFile;
  /** MAE startup file name */
  public String
    maeName;
  /** full MAE startup file path */
  public String
  maeFile;
  /** (opt) row in user file where expect FieldQ samples list */
  public int
    rowWithSamples= -1;
  /** row in user file expect FieldQ (Quant) or FieldGQ (GIPO+Quant) Fields list*/
  public int
    rowWithFields= -1;
  /** row in user file where expect FieldQ (Quant) or FieldGQ (GIPO+Quant) Data */
  public int
    rowWithData= -1;
  /** optional row in user FieldG separate GIPO file where expect Fields list */
  public int
    rowWithSepGIPOFields= -1;
  /** optional row in user FieldG separate GIPO file where expect Data */
  public int
    rowWithSepGIPOData= -1;
  /** max # of source fields */
  public int
    maxSrcFields= 0;
  /** highest SpotNbr generated */
  public int
    maxSpotNbr= 0;
  /** max # data rows expected in input file (GIPO+Quant or Quant files) */
  public int
    maxRowsExpected= 0;
  /** max # data rows expected in output file after add INFILL spots */
  public int
    maxRowsComputed= 0;
  /** highestID ("Location") seen */
  public int
    highestID= 0;
  /** Org=Hs or ORG=Mm, etc  */
  public String
    UniGeneSpeciesPrefix;
  /** version of the program */
  public String
    version= "";
  /* --- MAExplorer Configuration variables
   * These correspond to variables in MAExplorer.java or Config.java
   * --- */
  /* --- Array geometry parameters, int --- */
  /** PARAM: "MAX_FIELDS" # of duplicate grids */
  public int
    maxFields= 1;
  /** PARAM: "MAX_GRID_COLS" #cols/grid in array*/
  public int
    maxGridCols= 0;
  /** PARAM: "MAX_GRID_ROWS" #rows/grid in array*/
  public int
    maxGridRows= 0;
  /** PARAM: "MAX_GRIDS" # grids in array */
  public int
    maxGrids= 0;
  /** calculated: maxGrids*maxGridRows*maxGridCols */
  public int
    nbrGenesCalc= 0;
  /** calculated: maxFields*mcd.nbrGenesCalc */
  public int
    nbrSpotsCalc= 0;
  /** PARAM: "MAX_GENES" # Genes */
  public int
   nbrGENES= 0;
  /** PARAM: "MAX_SPOTS" # spots */
  public int
    nbrSPOTS= 0;
  /** PARAM: "SpotRadius" pseudo spot size */
  public int
    spotRadius= 7;
  /* --- Define PROP_xxxx has property bits --- */
  private long 
    pCalc= 1;
  /** has GeneClass GIPO data */
  public long
    PROP_GENECLASS= pCalc;
  /** has Plate GIPO data */
  public long
    PROP_PLATE_DATA= (pCalc *= 2);
  /** has I.M.A.G.E Clone IDs */
  public long
    PROP_CLONEID= (pCalc *= 2);
  /** has GenBank IDs */
  public long
    PROP_GENBANKID= (pCalc *= 2);
  /** has UniGene IDs */
  public long
    PROP_UNIGENEID= (pCalc *= 2);
  /** has dbESTs IDs */
  public long
    PROP_DBESTID= (pCalc *= 2);
  /** has LocusLink LocusIDs */
  public long
    PROP_LOCUSID= (pCalc *= 2);
  /** has SwissProt IDs */
  public long
    PROP_SWISSPROTID= (pCalc *= 2);
  /** has UniGene names */
  public long
    PROP_UNIGENE_NAME= (pCalc *= 2);
  /** quant data has XY coordinates */
  public long
    PROP_XYCOORDS= (pCalc *= 2);
  /** there is quant background data */
  public long
    PROP_BKGRD_DATA= (pCalc *= 2);
  /** has QualCheck Quant data */
  public long
    PROP_QUALCHK_SPOT_DATA= (pCalc *= 2);
  /** has QualCheck GIPO data */
  public long
    PROP_QUALCHK_GIPO_DATA= (pCalc *= 2);
  /** specify (grid,row,col) by Molecular Dynamics "NAME_GRC" spec */
  public long
    PROP_NAME_GRC= (pCalc *= 2);
  /** specify allowNegQuantDataFlag */
  public long
    PROP_ALLOW_NEG_DATA= (pCalc *= 2);
  /** has Location IDs */
  public long
    PROP_LOCATION= (pCalc *= 2);
  /** specify XXXX3 */
  public long
    PROP_SEPARATE_GIPO_AND_QUANT_FILES= (pCalc *= 2);
  /** specify XXXX4 */
  public long
   PROP_USE_SRC_TMP_FILE_FLAG= (pCalc *= 2);
  /** specify XXXX5 */
  public long
    PROP_USE_2ND_INPUT_CHIP_FILE_FLAG= (pCalc *= 2);
  /** specify XXXX6 */
  public long
    PROP_XXXX6= (pCalc *= 2);
  /** specify XXXX7 */
  public long
    PROP_XXXX7= (pCalc *= 2);
  /** specify XXXX8 */
  public long
    PROP_XXXX8= (pCalc *= 2);
  /** specify XXXX9 */
  public long
    PROP_XXXX9= (pCalc *= 2);
  /** specify XXXX10 */
  public long
    PROP_XXXX10= (pCalc *= 2);
  /** have GeneClass GIPO data */
  public boolean
    hasGeneClassDataFlag= false;
  /** have Plate GIPO data */
  public boolean
    hasPlateDataFlag= false;
  /** have I.M.A.G.E Clone IDs */
  public boolean
    hasCloneIDsFlag= true;
  /** have GenBank IDs */
  public boolean
    hasGenBankIDsFlag= true;
  /** have UniGene IDs */
  public boolean
  hasUniGeneIDsFlag= false;
  /** have dbESTs IDs */
  public boolean
  hasDB_ESTIDsFlag= false;
  /** have LocusLink LocusIDs */
  public boolean
  hasLocusIDsFlag= false;
  /** have SwissProt IDs */
  public boolean
  hasSwissProtIDsFlag= false;
  /** have UniGene names */
  public boolean
  hasUniGeneNameFlag= false;
  /** quant data has XY coordinates */
  public boolean
    hasQuantXYcoordsFlag= false;
  /** there is quant background data */
  public boolean
    hasBkgrdDataFlag= false;
  /** have QualCheck Quant data */
  public boolean
    hasQualCheckQuantDataFlag= false;
  /** have QualCheck GIPO data */
  public boolean
    hasQualCheckGIPOdataFlag= false;
  /** specify (grid,row,col) by Molecular Dynamics "NAME_GRC" spec */
  public boolean
    useMolDyn_NAME_GRC_specFlag= false;
  /** use Location identifier */
  public boolean
    hasLocationIdFlag= false;
  
  /** PARAM: "specifyGeometryByNbrSpotsFlag" indicates pseudo array geometry
   * (F,G,R,C) is generated by the number of genes in GIPO file.
   */
  public boolean
  specifyGeometryByNbrSpotsFlag= false;
  /** PARAM: "specifyByGridGeometryFlag" (future) indicates whether data was
   * generated explicity (F,G,R,C) or by expected # of genes.
   */
  public boolean
  specifyByGridGeometryFlag= false;
  /** PARAM: "FIELDS_ARE_NUMBERED" (future) Data files contain field
   *  number. Otherwise field is extrapolated
   */
  public boolean
  fieldsAreNumbered= false;
  
  /** PARAM: "GRID_LAYOUT" (future) Grids are Top to Bottom or
   * Left to Right in the array
   */
  public String
    gridLayout= "TtoB";
  /** PARAM: "FIELD_LAYOUT" (future) fields are Left to Right */
  public String
    fieldLayout= "LtoR";
  
  /** PARAM: "GRID_PER_ROW" (future) # grids per row in each
   *  field of the array */
  public int
    gridsPerRow= 1;
  
  /* Ratio and background parameters */
  /** PARAM: "fluorescentLbl1" (ratio) dye name for fluorescent label 1 */
  public String
    fluorescentLbl1= "Cy3";
   /** PARAM: "fluorescentLbl2" (ratio) dye name for fluorescent label 2 */
  public String
    fluorescentLbl2= "Cy5";	   
  /** PARAM: "useRatioData" set if data is Cy3/Cy5 ratio data, else
   * it assumes intensity data for each spot */
   public boolean
      useRatioDataFlag= false;
   
  /* Names of database, etc.  */
   
  
  /** PARAM: "calibDNAname"(opt) name for calibration DNA */
  public String
    calibDNAname= "";
  /** PARAM: "classNameX"(opt) default HP-X probe 'set'*/
  public String
    classNameX= "HP-X 'set'";
  /** PARAM: "classNameY"(opt) default HP-Y probe 'set'*/
  public String
    classNameY= "HP-Y 'set'";
  /** PARAM: "dataBase" (opt) name of the database*/
  public String
    database= "";
  /** PARAM: "dbSubset" (opt) name of the subset of DB */
  public String
    dbSubset= "";
  /** PARAM: "maAnalysisProgram" (opt) name of spot quant program*/
  public String
    maAnalysisProg= "";
  /** PARAM: "yourPlateName" (opt) name of researcher's clones */
  public String
    yourPlateName= "";
  /*  PARAM: For Empty well mapping subst */
  public String
    emptyWellName= "Empty";
  /** PARAM: "editDate" generated by program*/
  public String
  editDate= "";
    
  
  /* Default threshold database-specific configuration */
  /** PARAM: "CanvasHorSize"(opt) pixels, horiz. uArray image size*/
  public int
    canvasHSize= 1100;
  /** PARAM: "CanvasVertSize"(opt) pixels, vertical uArray image size*/
  public int
    canvasVSize= 1600;
  
  /** PARAM: "allowNegQuantDataFlag"(eg. AFFY) set if .quant data has
   * negative intensity values otherwise it clips the negative values to 0.0
   */
  public boolean
    allowNegQuantDataFlag= false;
  /** PARAM: "usePosQuantDataFlag"Filter out genes where .quant file data has negative intensity values otherwise it uses the negative data */
  public boolean
    usePosQuantDataFlag= false;
  
  /* Array specific auxiliary database files */
  /** PARAM: "gipoFile" GIPO file spot print order file.*/
  public String
    arrayGipoFile= "";
  /** PARAM: "samplesDBfile"  DB list of hybridized probe samples file */
  public String
    samplesDBfile= "";
  
  /** PARAM: "quantFileExt" alternate quantification spot file ext  instead of ".quant"*/
  public String
    quantFileExt= ".quant";
  
  /* Configuration genomic database base address URLs.
   * [TODO] VERIFY THESE VALUES.
   */
  
  /** PARAM: "dbEstURL" NCBI dbEst server by dbEST ID */
  public String
    dbEstURL= "http://www.ncbi.nlm.nih.gov/irx/cgi-bin/birx_doc?dbest+";
  /** PARAM: "genBankAccURL" NCBI GenBank server by GenBankAcc ID */
  public String
    genBankAccURL= "http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?"+
                   "db=2&form=1&term=";
  /** PARAM: "genBankCloneURL" NCBI GenBank entry by Clone_ID server */
  public String
    genBankCloneURL= "http://www.ncbi.nlm.nih.gov/irx/cgi-bin/"+
                     "submit_form_query?TITLE=dbEST+Retrieval+Output&"+
                     "INPUTS=1&BRACKETS=NONE&ADDFLAGS=-b&DB=dbest&NDOCS=10&Q1=";
  /** PARAM: "genBankCloneURLepilogue" Epilog added after Clone_ID */
  public String
    genBankCloneURLepilogue= "[clin]";
  
  /** PARAM: "IMAGE2GenBankURL" lookup GenBank entry from CloneID
   * server.  The "ORG=Mm" should be changed to reflect the proper
   * species, eg. "ORG=Hs" for human, ORG="Mm" for mouse, etc.*/
  public String
    IMAGE2GenBankURL= "http://nciarray.nci.nih.gov/cgi-bin/UG_query.cgi?"+
                      "ORG="+species+"&ACC=IMAGE:";
  
  /** PARAM: "IMAGE2GIDURL" NCI/CIT lookup GenBank GID from CloneID
   * server. The "ORG=Mm" should be changed to reflect the proper
   * species, eg. "ORG=Hs" for human, ORG="Mm" for mouse, etc. */
  public String
    IMAGE2GidURL= "http://nciarray.nci.nih.gov/cgi-bin/UG_query.cgi?"+
                  "ORG="+species+"&GID=IMAGE";
  
  /** PARAM: "IMAGE2unigeneURL" NCI/CIT lookup UNIGENE from CloneID
   * server. The "ORG=Mm" should be changed to reflect the proper
   * species, eg. "ORG=Hs" for human, ORG="Mm" for mouse, etc. */
  public String
    IMAGE2unigeneURL= "http://nciarray.nci.nih.gov/cgi-bin/UG_query.cgi?"+
                      "ORG="+species+"&CLONE=IMAGE:";
  
  /** PARAM: "uniGeneURL" NCBI UNIGENE by Clone ID server.  The "ORG=Mm"
   * should be changed to reflect the proper species, eg. "ORG=Hs" for
   * human, ORG="Mm" for mouse, etc. */
  public String
    uniGeneURL= "http://www.ncbi.nlm.nih.gov/UniGene/clust.cgi?ORG="+
                species+"&CID=";
  /** PARAM: "geneCardURL" GeneCard DB server. */
  public String
    geneCardURL= "http://bioinfo.weizmann.ac.il/cards-bin/carddisp?";
  /** PARAM: "histologyURL" histology DB server. Add specific entry
   * from the SamplesDB table. */
  public String
    histologyURL= "";
  
  /** PARAM: "modelsURL" mouse (or other) models DB server. Add
   * specific entry from the SamplesDB table */
  public String
    modelsURL= "";
  
  /** PARAM: "proxyServer"
   * proxy server to access servers outside of
   * Java "sandbox". This should point to a
   * proxy server on your system.*/
  public String
    proxyServer= "";
  
  /** PARAM: "swissProtURL" Swiss Prot database server. */
  public String
    swissProtURL= "";
  /** PARAM: "pirURL" PIR database server */
  public String
    pirURL= "";
  /** PARAM: "medMinerURL" MedMiner database server */
  public String
    medMinerURL= "";
  /** PARAM: "medMinerURLepilogue" MedMiner database server */
  public String
    medMinerURLepilogue= "";
  
  /** PARAM: "mAdbUrl" NCI/CIT mAdb/ATC array clone report server. Add
   * 'CloneID' at end of string*/
  public String
    mAdbURL= "http://nciarray.nci.nih.gov/cgi-bin/clone_report.cgi?"+
            "CRITERIA=clone&PARAMETER=";
  
  /** PARAM: "gbid2LocusLinkURL" NCBI GBID to LocusLink server.  Add
   * 'GBID' at end of string */
  public String
    gbid2LocusLinkURL= "http://www.ncbi.nlm.nih.gov/LocusLink/list.cgi?ORG=&V=0&Q=+";
  /** PARAM: "locusLinkURL" NCBI LocusLink server.  Add 'LocusID' at
   * end of string */
  public String
  locusLinkURL= "http://www.ncbi.nlm.nih.gov/LocusLink/list.cgi?SITE=104&V=1&"+
                "ORG=Hs&ORG=Mm&ORG=Rn&ORG=Dr&ORG=Dm&Q=";
  
  /* (opt) Genomic (Menu,URL,requiredID) lists */
  /** PARAM: "GenomicMenuj"  sub menu title*/
  public String
    genomicMenu[]= null;
  /** PARAM: "GenomicURLj" sub menu URL */
  public String
    genomicURL[]= null;
  /** PARAM: "GenomicURLepiloguej" sub menu URL */
  public String
    genomicURLepilogue[]= null;
  /** PARAM: "GenomicIDreqj" sub menu required ID */
  public String
    genomicIDreq[]= null;
  /** size of genomicMenu[] data arrays */
  public int
    nGenomicMenu;      
  
  /* Configuration database-specific user menu (opt) */
  
  /** PARAM: "helpMenuj" Help sub menu title*/
  public String
    helpMenu[]= {"MAExplorer home page",
                 "MAExplorer reference manual",
                 "MAExplorer HELP"};
   /** PARAM: "helpURLj" Help sub menu URL */
   public String
     helpURL[]= {"http://maexplorer.sourceforge.net/",
                 "http://maexplorer.sourceforge.net/MAExplorer/hmaeHelp.html",
                 "mailto:mae@ncifcrf.gov"};
    /** size of help data arrays */
    public int
      nHelpMenu= helpMenu.length;
    /** PARAM: "useCy5/Cy3" switch all Cy3/Cy5 to Cy5/Cy3 */
    public boolean
      useCy5OverCy3Flag= false;
    /** PARAM: "useMouseOver"  enable mouse over */
    public boolean
      useMouseOverFlag= true;
    /** PARAM: "swapRowsColumns" swap rows and columns */
    public boolean
      swapRowsColsFlag= false;
    /** PARAM: "useBackgroundCorrection" enable background coorection */
    public boolean
     bkgdCorrectFlag= false;
    /** PARAM: "useRatioMedianCorrection"  use ratio median corrct Cy3/Cy5 */
    public boolean
      ratioMedianCorrectionFlag= false;
    /** PARAM: "usePseudoXYcoords" generate Pseudo XY coords */
    public boolean
      usePseudoXYcoordsFlag= true;
    /** PARAM: "reuseXYcoords" if specify XY; reuse fist HP's */
    public boolean
      reuseXYcoordsFlag= false;
    /** PARAM: "ignoreExtraFields" ignore extra fields in .quant */
    public boolean
      ignoreExtraFIELDS= false;
    /** PARAM: "presentationViewFlag" use large default fond */
    public boolean
      presentViewFlag= false;
    /** PARAM: "clusterDistThr" initial cluster threshold */
    public float
      clusterDistThr= 10.0F;
    /** PARFAM: "pctOKthr" percent spots OK threshold */
    public float
    pctOKthr= 50.0F;
    /** PARAM: "diffThr" init difference threshold */
    public float
      diffThr= 0.20F;
    /** PARAM: "pValueThr" initial pValue threshold */
    public float
     pValueThr= 0.05F;
    /** PARAM: "spotCVthr" initial spot CV threshold */
    public float
      spotCVthr= 0.20F;
    
    /** PARAM: "maxClonesReported" initial # genes to report */
    public int
      maxGenesToRpt= 100;
    /** PARAM: "nbrOfClustersThr" initial # of K-means clusters */
    public int
      nbrOfClustersThr= 6;
    /** if file is saved */
    boolean
      fileSavedFlag= false;
    /** for newline, Mac= "\r" Sun ="\n" PC= "\r\n" */
    public String
      newline;
    
    
    /**
     * MaeConfigData() - constructior. This sets up the data structure
     * with hardwired default values. This should generally be
     * overridden using data from either a file or Cvt2Mae.
     * @see #initMCD
     */
    public MaeConfigData()
    { /* MaeConfigData */
      initMCD();                 /* init data structures */
    } /* MaeConfigData */
    
    
    /**
     * MaeConfigData() - constructior
     * @param maxSrcFields maximum number of source fields
     * @see #initMCD
     */
    public MaeConfigData(int maxSrcFields)
    { /* MaeConfigData */
      this.maxSrcFields= maxSrcFields;
      initMCD();                 /* init data structures */
    } /* MaeConfigData */
    
    
    /**
     * resetMaeConfigData() -  make copy of initial mcd Edit data.<BR>
     * [NOTE] If the states are changed, this must be changed as well (all
     * variables).
     * @param mcd instance of MaeConfigData
     */
    public MaeConfigData resetMaeConfigData(MaeConfigData mcd)
    { /* resetMaeConfigData */
      MaeConfigData mcdNew= new MaeConfigData(); /* to be returned w/ new values */
      
      /* [1] Copy data from arrayLayoutNamePanel_PP() */
      mcdNew.layoutName= mcd.layoutName;
      mcdNew.aloFileName= mcd.aloFileName;
      
      /* [2] Copy data from GeometricPanel_PP() */
      mcdNew.maxFields= mcd.maxFields;
      mcdNew.maxGrids= mcd.maxGrids;
      mcdNew.maxGridRows= mcd.maxGridRows;
      mcdNew.maxGridCols= mcd.maxGridCols;
      mcdNew.maxRowsExpected= mcd.maxRowsExpected;
      mcdNew.maxRowsComputed= mcd.maxRowsComputed;  /* computed */
      mcdNew.nbrGenesCalc= mcd.nbrGenesCalc;
      mcdNew.nbrSpotsCalc= mcd.nbrSpotsCalc;
      mcdNew.spotRadius= mcd.spotRadius;
      
      /* [3] Copy data from InputFileRowsPanel_PP() */
      mcdNew.rowWithSamples= mcd.rowWithSamples;
      mcdNew.rowWithFields= mcd.rowWithFields;
      mcdNew.rowWithData= mcd.rowWithData;
      
      mcdNew.rowWithSepGIPOFields= mcd.rowWithSepGIPOFields;
      mcdNew.rowWithSepGIPOData= mcd.rowWithSepGIPOData;
      
      mcdNew.commentToken= mcd.commentToken;
      mcdNew.initialKeyword= mcd.initialKeyword;
      mcdNew.hasMultDatasetsFlag= mcd.hasMultDatasetsFlag;  /* computed*/
      
      /* [4] Copy data from fluoresentPanel_PP() */
      mcdNew.useRatioDataFlag= mcd.useRatioDataFlag;
      mcdNew.useCy5OverCy3Flag= mcd.useCy5OverCy3Flag;
      mcdNew.hasBkgrdDataFlag= mcd.hasBkgrdDataFlag;
      mcdNew.fluorescentLbl1= mcd.fluorescentLbl1;
      mcdNew.fluorescentLbl2= mcd.fluorescentLbl2;
      
      /* [4] Copy data from XYcoordsPanel_PP() */
      mcdNew.usePseudoXYcoordsFlag= mcd.usePseudoXYcoordsFlag;
      mcdNew.hasQuantXYcoordsFlag= mcd.hasQuantXYcoordsFlag;
      mcdNew.reuseXYcoordsFlag= mcd.reuseXYcoordsFlag;
      mcdNew.swapRowsColsFlag= mcd.swapRowsColsFlag;
      
      /* [5] Copy data from GenomicIDsPanel_PP() */
      mcdNew.hasLocationIdFlag= mcd.hasLocationIdFlag;
      mcdNew.hasCloneIDsFlag= mcd.hasCloneIDsFlag;
      mcdNew.hasGenBankIDsFlag= mcd.hasGenBankIDsFlag;
      mcdNew.hasUniGeneIDsFlag= mcd.hasUniGeneIDsFlag;
      mcdNew.hasDB_ESTIDsFlag= mcd.hasDB_ESTIDsFlag;
      mcdNew.hasLocusIDsFlag= mcd.hasLocusIDsFlag;
      mcdNew.hasSwissProtIDsFlag= mcd.hasSwissProtIDsFlag;
      mcdNew.hasPlateDataFlag= mcd.hasPlateDataFlag;
      
      /* [6] Copy data from GeneNamesPanel_PP() */
      mcdNew.hasGeneClassDataFlag= mcd.hasGeneClassDataFlag;
      mcdNew.hasUniGeneNameFlag= mcd.hasUniGeneNameFlag;
      mcdNew.hasQualCheckQuantDataFlag= mcd.hasQualCheckQuantDataFlag;
      mcdNew.hasQualCheckGIPOdataFlag= mcd.hasQualCheckGIPOdataFlag;
      
      /* [7] Copy data from DNAcalibPanel_PP() */
      mcdNew.calibDNAname= mcd.calibDNAname;
      mcdNew.yourPlateName= mcd.yourPlateName;
      mcdNew.emptyWellName= mcd.emptyWellName;
      mcdNew.UniGeneSpeciesPrefix= mcd.UniGeneSpeciesPrefix;
      
      /* [8] Copy data from databasePanel_PP() */
      mcdNew.database= mcd.database;
      mcdNew.dbSubset= mcd.dbSubset;
      mcdNew.dbPrjName= mcd.dbPrjName;
      mcdNew.maAnalysisProg= mcd.maAnalysisProg;
      
      /* [9] Copy data from classNamePanel_PP() */
      mcdNew.classNameX= mcd.classNameX;
      mcdNew.classNameY= mcd.classNameY;
      
      /* [10] Copy data from thresholdsPanel_PP() */
      mcdNew.clusterDistThr= mcd.clusterDistThr;
      mcdNew.maxGenesToRpt= mcd.maxGenesToRpt;
      mcdNew.nbrOfClustersThr= mcd.nbrOfClustersThr;
      mcdNew.pValueThr= mcd.pValueThr;
      mcdNew.spotCVthr= mcd.spotCVthr;
      mcdNew.diffThr= mcd.diffThr;
      
      /* [11] Copy data from filesPanel_PP() */
      mcdNew.gipoFile= mcd.gipoFile;
      mcdNew.samplesDBfile= mcd.samplesDBfile;
      mcdNew.quantFileExt= mcd.quantFileExt;
      
      /* [11] Add the optional GEO ID*/
      mcdNew.geoPlatformID= geoPlatformID;
      
      mcdNew.newline= mcd.newline;
      
      return(mcdNew);
    } /* resetMaeConfigData */
    
    
    /**
     * restoreMCDstate() - Restore the original state to this instance
     * @param mcdSrc - copy data from the mcdSrc to this
     */
    public void restoreMCDstate(MaeConfigData mcdSrc)
    { /* restoreMCDstate */
      /* [1] Copy data from arrayLayoutNamePanel_PP() */
      this.layoutName= mcdSrc.layoutName;
      this.aloFileName= mcdSrc.aloFileName;
      
      /* [2] Copy data from GeometricPanel_PP() */
      this.maxFields= mcdSrc.maxFields;
      this.maxGrids= mcdSrc.maxGrids;
      this.maxGridRows= mcdSrc.maxGridRows;
      this.maxGridCols= mcdSrc.maxGridCols;
      this.maxRowsExpected= mcdSrc.maxRowsExpected;
      this.maxRowsComputed= mcdSrc.maxRowsComputed;  /* computed */
      this.nbrGenesCalc= mcdSrc.nbrGenesCalc;
      this.nbrSpotsCalc= mcdSrc.nbrSpotsCalc;
      this.spotRadius= mcdSrc.spotRadius;
      
      /* [3] Copy data from InputFileRowsPanel_PP() */
      this.rowWithSamples= mcdSrc.rowWithSamples;
      this.rowWithFields= mcdSrc.rowWithFields;
      this.rowWithData= mcdSrc.rowWithData;
      
      this.rowWithSepGIPOFields= mcdSrc.rowWithSepGIPOFields;
      this.rowWithSepGIPOData= mcdSrc.rowWithSepGIPOData;
      
      this.commentToken= mcdSrc.commentToken;
      this.initialKeyword= mcdSrc.initialKeyword;
      this.hasMultDatasetsFlag= mcdSrc.hasMultDatasetsFlag;  /* computed*/
      
      /* [3.1] Copy data from fluoresentPanel_PP() */
      this.useRatioDataFlag= mcdSrc.useRatioDataFlag;
      this.useCy5OverCy3Flag= mcdSrc.useCy5OverCy3Flag;
      this.hasBkgrdDataFlag= mcdSrc.hasBkgrdDataFlag;
      this.fluorescentLbl1= mcdSrc.fluorescentLbl1;
      this.fluorescentLbl2= mcdSrc.fluorescentLbl2;
      
      /* [4] Copy data from XYcoordsPanel_PP() */
      this.usePseudoXYcoordsFlag= mcdSrc.usePseudoXYcoordsFlag;
      this.hasQuantXYcoordsFlag= mcdSrc.hasQuantXYcoordsFlag;
      this.reuseXYcoordsFlag= mcdSrc.reuseXYcoordsFlag;
      this.swapRowsColsFlag= mcdSrc.swapRowsColsFlag;
      
      /* [5] Copy data from GenomicIDsPanel_PP() */
      this.hasLocationIdFlag= mcdSrc.hasLocationIdFlag;
      this.hasCloneIDsFlag= mcdSrc.hasCloneIDsFlag;
      this.hasGenBankIDsFlag= mcdSrc.hasGenBankIDsFlag;
      this.hasUniGeneIDsFlag= mcdSrc.hasUniGeneIDsFlag;
      this.hasDB_ESTIDsFlag= mcdSrc.hasDB_ESTIDsFlag;
      this.hasLocusIDsFlag= mcdSrc.hasLocusIDsFlag;
      this.hasSwissProtIDsFlag= mcdSrc.hasSwissProtIDsFlag;
      this.hasPlateDataFlag= mcdSrc.hasPlateDataFlag;
      
      /* [6] Copy data from GeneNamesPanel_PP() */
      this.hasGeneClassDataFlag= mcdSrc.hasGeneClassDataFlag;
      this.hasUniGeneNameFlag= mcdSrc.hasUniGeneNameFlag;
      this.hasQualCheckQuantDataFlag= mcdSrc.hasQualCheckQuantDataFlag;
      this.hasQualCheckGIPOdataFlag= mcdSrc.hasQualCheckGIPOdataFlag;
      
      /* [7] Copy data from DNAcalibPanel_PP() */
      this.calibDNAname= mcdSrc.calibDNAname;
      this.yourPlateName= mcdSrc.yourPlateName;
      this.emptyWellName= mcdSrc.emptyWellName;
      this.UniGeneSpeciesPrefix= mcdSrc.UniGeneSpeciesPrefix;
      
      /* [8] Copy data from databasePanel_PP() */
      this.database= mcdSrc.database;
      this.dbSubset= mcdSrc.dbSubset;
      this.dbPrjName= mcdSrc.dbPrjName;
      this.maAnalysisProg= mcdSrc.maAnalysisProg;
      
      /* [9] Copy data from classNamePanel_PP() */
      this.classNameX= mcdSrc.classNameX;
      this.classNameY= mcdSrc.classNameY;
      
      /* [10] Copy data from thresholdsPanel_PP() */
      this.clusterDistThr= mcdSrc.clusterDistThr;
      this.maxGenesToRpt= mcdSrc.maxGenesToRpt;
      this.nbrOfClustersThr= mcdSrc.nbrOfClustersThr;
      this.pValueThr= mcdSrc.pValueThr;
      this.spotCVthr= mcdSrc.spotCVthr;
      this.diffThr= mcdSrc.diffThr;
      
      /* [11] Copy data from filesPanel_PP() */
      this.gipoFile= mcdSrc.gipoFile;
      this.samplesDBfile= mcdSrc.samplesDBfile;
      this.quantFileExt= mcdSrc.quantFileExt;
      
      /* [12] Add the optional GEO ID*/
      this.geoPlatformID= mcdSrc.geoPlatformID;
      
      this.newline= mcdSrc.newline;
    } /* restoreMCDstate */
    
    
    /**
     * initMCD() - init data structures
     * @see MaeStartupData
     * @see MaeSampleData
     */
    private void initMCD()
    { /* initMCD */
      fileSep= System.getProperty("file.separator");
      userDir= System.getProperty("user.dir")+fileSep;
      
      String osName= System.getProperty("os.name");
      boolean isMacFlag= osName.startsWith("Mac OS");
      if(isMacFlag)
        newline= System.getProperty("line.separator");
      else
        newline= "\n";
      
      maePrjDir= userDir;	/* [CHECK] who sets? set default path */
      aloDir= maePrjDir + "ArrayLayout" + fileSep;
      
      existingPrjDir= null;	/* set by project */
      
      nSrcFiles= 0;		                          /* set up empty source list */
      nQuantFiles= 0;		                        /* may not be 1:1 */
      srcFile= new String[maxSrcFields];
      tmpSrcFile= new String[maxSrcFields];
      prjName= new String[maxSrcFields];
      linesInFile= new int[maxSrcFields];
      swapCy5Cy3DataFlag= new boolean[maxSrcFields];
      
      quantDstFile= new String[maxSrcFields];       /* where WRITE .quant */
      quantName= new String[maxSrcFields];       /* may be renamed */
      quantNameOrig= new String[maxSrcFields];   /* original name */
      
      quantSampleNbrInFile= new int[maxSrcFields];
      quantSrcFieldNbr= new int[maxSrcFields];   /* file where found */
      quantSrcFile= new String[maxSrcFields];
      quantSrcDir= new String[maxSrcFields];
      fullSampleName= new String[maxSrcFields];
      
      /* Make substructures */
      msud= new MaeStartupData(this);
      msd= new MaeSampleData(this);
    } /* initMCD */
    
    
    /**
     * setMCDstateFromBitProp() - set MCD state from mcd.hasXXXX bitProps
     * @param bitProps long encoded property bits
     */
    public void setMCDstateFromBitProp(long bitProps)
    { /* setMCDstateFromBitProp */
      hasGeneClassDataFlag= ((bitProps & PROP_GENECLASS)!=0);
      hasPlateDataFlag= ((bitProps & PROP_PLATE_DATA)!=0);
      hasCloneIDsFlag= ((bitProps & PROP_CLONEID)!=0);
      hasGenBankIDsFlag= ((bitProps & PROP_GENBANKID)!=0);
      hasUniGeneIDsFlag= ((bitProps & PROP_UNIGENEID)!=0);
      hasDB_ESTIDsFlag= ((bitProps & PROP_DBESTID)!=0);
      hasLocusIDsFlag= ((bitProps & PROP_LOCUSID)!=0);
      hasSwissProtIDsFlag= ((bitProps & PROP_SWISSPROTID)!=0);
      hasUniGeneNameFlag= ((bitProps & PROP_UNIGENE_NAME)!=0);
      hasQuantXYcoordsFlag= ((bitProps & PROP_XYCOORDS)!=0);
      hasBkgrdDataFlag= ((bitProps & PROP_BKGRD_DATA)!=0);
      hasQualCheckQuantDataFlag= ((bitProps & PROP_QUALCHK_SPOT_DATA)!=0);
      hasQualCheckGIPOdataFlag= ((bitProps & PROP_QUALCHK_GIPO_DATA)!=0);
      useMolDyn_NAME_GRC_specFlag= ((bitProps & PROP_NAME_GRC)!=0);
      allowNegQuantDataFlag= ((bitProps & PROP_ALLOW_NEG_DATA)!=0);
      hasLocationIdFlag= ((bitProps & PROP_LOCATION)!=0);
      hasSeparateGIPOandQuantFilesFlag= ((bitProps & PROP_SEPARATE_GIPO_AND_QUANT_FILES)!=0);
      useSrcTmpFileFlag= ((bitProps & PROP_USE_SRC_TMP_FILE_FLAG)!=0);
      use2ndInputChipFileFlag= ((bitProps & PROP_USE_2ND_INPUT_CHIP_FILE_FLAG)!=0);
    } /* setMCDstateFromBitProp */
    
    
    /**
     * calcBitPropFromMCDstate() - set bitProps mcd.hasXXXX from MCD state
     * @return property bits computed from the state
     */
    public long calcBitPropFromMCDstate()
    { /* calcBitPropFromMCDstate */
      long bitProps= 0;
      
      if(hasGeneClassDataFlag)
        bitProps |= PROP_GENECLASS;
      if(hasPlateDataFlag)
        bitProps |= PROP_PLATE_DATA;
      if(hasCloneIDsFlag)
        bitProps |= PROP_CLONEID;
      if(hasGenBankIDsFlag)
        bitProps |= PROP_GENBANKID;
      if(hasUniGeneIDsFlag)
        bitProps |= PROP_UNIGENEID;
      if(hasDB_ESTIDsFlag)
        bitProps |= PROP_DBESTID;
      if(hasLocusIDsFlag)
        bitProps |= PROP_LOCUSID;
      if(hasSwissProtIDsFlag)
        bitProps |= PROP_SWISSPROTID;
      if(hasUniGeneNameFlag)
        bitProps |= PROP_UNIGENE_NAME;
      if(hasQuantXYcoordsFlag)
        bitProps |= PROP_XYCOORDS;
      if(hasBkgrdDataFlag)
        bitProps |= PROP_BKGRD_DATA;
      if(hasQualCheckQuantDataFlag)
        bitProps |= PROP_QUALCHK_SPOT_DATA;
      if(hasQualCheckGIPOdataFlag)
        bitProps |= PROP_QUALCHK_GIPO_DATA;
      if(useMolDyn_NAME_GRC_specFlag)
        bitProps |= PROP_NAME_GRC;
      if(allowNegQuantDataFlag)
        bitProps |= PROP_ALLOW_NEG_DATA;
      if(hasLocationIdFlag)
        bitProps |= PROP_LOCATION;
      if(hasSeparateGIPOandQuantFilesFlag)
        bitProps |= PROP_SEPARATE_GIPO_AND_QUANT_FILES;
      if(useSrcTmpFileFlag)
        bitProps |= PROP_USE_SRC_TMP_FILE_FLAG;
      if(use2ndInputChipFileFlag)
        bitProps |= PROP_USE_2ND_INPUT_CHIP_FILE_FLAG;
      
      return(bitProps);
    } /* calcBitPropFromMCDstate */
    
    
    /**
     * setAllSamplesToDbPrjName() - set all of the samples to mcd.dbPrjName
     */
    public void setAllSamplesToDbPrjName()
    { /* setAllSamplesToDbPrjName */
      for(int i=0;i<nQuantFiles;i++)
        prjName[i]= dbPrjName;
    } /* setAllSamplesToDbPrjName */
    
    
    /**
     * calcGenomicMenuURLs() - compute set of valid Genomic URLs
     * This only uses entrys for the data that exists.
     */
    private void calcGenomicMenuURLs()
    { /* calcGenomicMenuURLs */
      String tgMenu[]= {"mAdb Clone report by Clone ID ",
                        "NCIARRAY GenBank by Clone ID",
                        "NCIARRAY UniGene by CloneID",
                        "NCBI UniGene by CloneID",
                        "MedMiner by Clone ID",
                        
                        "GenBank by GenBank ID",
                        "UniGene by GenBank ID",
                        "LocusLink by GenBank ID",
                        
                        "NCBI dbEST by dbEST ID",
                        
                        //"NCBI UniGene by UniGene ID",
                        
                        "LocusLink by LocusID",
                        
                        "SwissProt",
                        "NCBI GenBank by SwissProt ID",
                        "PIR ProClass by SwissProt ID",
                        
                        "GeneCard by GenbankID"
                       },         /* PARAM: "GenomicMenuj"  sub menu title*/

        tgURL[]= {"http://nciarray.nci.nih.gov/cgi-bin/clone_report.cgi?"+
                         "CRITERIA=clone&PARAMETER=",     /* mAdb By Clone ID */
                  "http://nciarray.nci.nih.gov/cgi-bin/UG_query.cgi?"+
                         "ORG="+species+"&ACC=IMAGE:",    /* GenBank by Clone ID */
                  "http://nciarray.nci.nih.gov/cgi-bin/UG_query.cgi?"+
                         "ORG="+species+"&CLONE=IMAGE:",  /* UniGene by Clone ID */
                  "http://www.ncbi.nlm.nih.gov/UniGene/query.cgi?ORG="+
                         species+"&TEXT=",                /* UniGene By Clone ID */
                  "http://discover.nci.nih.gov/textmining/cgi-bin/"+
                         "ngg-query.cgi?q=",              /* MedMiner by Clone ID */
                         
                  "http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?"+
                         "db=n&form=6&Dopt=g&uid=",       /* GenBank by GenBank ID */
                  "--todo--"+ "",                         /* UniGene by GenBank ID */
                  "http://www.ncbi.nlm.nih.gov/LocusLink/list.cgi?"+
                         "ORG=&V=0&Q=+",                  /* LocusLink by GenBank ID */
                         
                  "http://www.ncbi.nlm.nih.gov/irx/cgi-bin/birx_doc?dbest+",
                         /* dbEst ID */
                         
                         //"",			       /* UniGene by UniGene ID*/
                         
                  "http://www.ncbi.nlm.nih.gov/LocusLink/list.cgi?SITE=104&V=1&"+
                         "ORG=Hs&ORG=Mm&ORG=Rn&ORG=Dr&ORG=Dm&Q=", /* LocusID*/
                         
                  "http://www.expasy.ch/cgi-bin/get-sprot-entry?",
                         /* SwissProt */
                  "http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?"+
                         "db=n&form=6&Dopt=g&uid=",     /* GenBank by SwissProt ID */
                  "http://pir.georgetown.edu/cgi-bin/iproclass/iproclass?"+
                         "choice=entry&id=",             /* ProClass by SwissProt ID */
                      
                  "http://bioinfo.weizmann.ac.il/cards-bin/carddisp?"
                         /* "GeneCard by Genbank ID*/
                 },          /* PARAM: "GenomicURLj"sub menu URL */
      
        tgURLepilogue[]= {"",                        /* mAdb By Clone ID */
                          "",                        /* GenBank by Clone ID */
                          "",                        /* UniGene by Clone ID */
                          "",                        /* UniGene By Clone ID */
                          "&list=human_oncochip",    /* MedMiner by Clone ID */
                          
                          "",                        /* GenBank by GenBank ID */
                          "",                        /* UniGene by GenBank ID */
                          "",                        /* LocusLink by GenBank ID */
                          
                          "",                        /* dbEST */
                          
                          //"",                      /* NCBI UniGene by UniGene ID */
                          
                          "",                        /* LocusID */
                          
                          "",                        /* SwissProt */
                          "",                        /* GenBank by SwissProt ID */
                          "",                        /* ProClass by SwissProt ID */
                          
                          ""			        /* GeneCard by Genbank ID*/
                       },        /* PARAM: "GenomicURLepiloguej" sub menu URL
                                 * epilogue if any */
      
      tgIDreq[]= {"Clone ID",                /* mAdb By Clone ID */
                  "Clone ID",                /* GenBank by Clone ID */
                  "Clone ID",                /* UniGene by Clone ID */
                  "Clone ID",                /* UniGene By Clone ID */
                  "&list=human_oncochip",    /* MedMiner by Clone ID */
                  
                  "GenBank",                 /* GenBank by GenBank ID */
                  "GenBank",                 /* UniGene by GenBank ID */
                  "GenBank",                 /* LocusLink by GenBank ID */
                  
                  "dbEST",                   /* dbEST by dbEST ID */
                  
                  //"UniGene ID",            /* NCBI UniGene by UniGene ID */
                  
                  "LocusID",                 /* LocusID*/
                  
                  "SwissProt",               /* SwissProt */
                  "SwissProt",               /* GenBank by SwissProt ID */
                  "SwissProt",               /* ProClass by SwissProt ID */
                  
                  "GenBank"		        /* GeneCard by Genbank ID */
                 };     /* PARAM: "GenomicIDreqj" sub menu  required ID */

      int
        nTG= tgMenu.length,     /* maximum available */
        nG= 0;                  /* # actually used */
      
      boolean
        hasCloneIDFlag= true,    /* [TODO] analyze GIPO data */
        hasGenBankFlag= true,
        hasUniGeneFlag= true,
        hasLocusIDFlag= true,
        hasSwissProtFlag= true;

      String
        gMenu[]= new String[nTG],
        gURL[]= new String[nTG],
        gURLepilogue[]= new String[nTG],
        gIDreq[]= new String[nTG];

      /* Analyze GBID genomic IDs to see what we should output */
      for(int i=0; i<nTG;i++)
      { /* check for existing IDs */
        String gid= tgIDreq[i];
        if((hasCloneIDFlag && gid.equals("Clone ID")) ||
           (hasGenBankFlag && gid.equals("GenBank")) ||
           (hasUniGeneFlag && gid.equals("UniGeneID")) ||
           (hasLocusIDFlag && gid.equals("LocusID")) ||
           (hasSwissProtFlag && gid.equals("SwissProt")))
        { /* use it */
          gMenu[nG]= tgMenu[i];
          gURL[nG]= tgURL[i];
          gURLepilogue[i]= tgURLepilogue[i];
          gIDreq[nG++]= gid;
        } /* use it */
      } /* check for existing IDs */
      
      /* Copy final list to globals */
      genomicMenu= gMenu;
      genomicURL= gURL;
      genomicURLepilogue= gURLepilogue;
      genomicIDreq= gIDreq;
      nGenomicMenu= genomicMenu.length;  /** size of genomic data arrays */
    } /* calcGenomicMenuURLs */
    
    
    /**
     * createMAEproject() -  make project dirs, Config/, MAE/ Quant/
     * and setup files in these directories.
     * @return true if successful
     * @see #checkAndMakeMAEdirTree
     * @see MaeSampleData#writeSamplesFile
     * @see MaeStartupData#writeMAEstartupFile
     * @see #writeConfigFile
     */
    public boolean createMAEproject() throws IOException
    { /* createMAEproject */
      if(!checkAndMakeMAEdirTree(maePrjDir))
        return(false);
      
      /* Create MAE/Start.mae file */
      if(!msud.writeMAEstartupFile())
        return(false);
      
      /* Create Config/MaExplorerConfig-fn.txt file */
      if(!writeConfigFile())
        return(false);
      
      /* Create Config/Samples-fn.txt file */
      if(!msd.writeSamplesFile())
        return(false);
      
      return(true);
    } /* createMAEproject */
    
    
    /**
     * checkAndMakeMAEdirTree()- check for MAE prject directory tree.
     * Containg directories (/MAE /Quant /Config /State /Report /Cache).
     * If not found, then create the MAE project directory tree.
     * Return true if successful.
     * @param maePrjDir MAE project directory
     * @return true if successful
     */
    public boolean checkAndMakeMAEdirTree(String maePrjDir)
    { /* checkAndMakeMAEdirTree */
      try
      {
        File
          f= new File(maePrjDir),
          fCache,
          fConfig,
          fMAE,
          fQuant,
          fReport,
          fState;
        
        if(!f.isDirectory())
          f.mkdirs();             /* make it */
        
        String
          sCachePath= maePrjDir + "Cache" + fileSep,
          sConfigPath= maePrjDir + "Config" + fileSep,
          sMAEPath= maePrjDir + "MAE" + fileSep,
          sQuantPath= maePrjDir + "Quant" + fileSep,
          sReportPath= maePrjDir + "Report" + fileSep,
          sStatePath= maePrjDir + "State" + fileSep;

        if(!(fCache= new File(sCachePath)).isDirectory())
          fCache.mkdirs();
        if(!(fConfig= new File(sConfigPath)).isDirectory())
          fConfig.mkdirs();
        if(!(fMAE= new File(sMAEPath)).isDirectory())
          fMAE.mkdirs();
        if(!(fQuant= new File(sQuantPath)).isDirectory())
          fQuant.mkdirs();
        if(!(fReport= new File(sReportPath)).isDirectory())
          fReport.mkdirs();
        if(!(fState= new File(sStatePath)).isDirectory())
          fState.mkdirs();
        
        return(true);
      }
      
      catch (Exception e)
      {
        return(false);
      }
    } /* checkAndMakeMAEdirTree */
    
    
    /**
     * writeConfigFile() - create Config/MaExplorerConfig-fn.txt file
     * The data must be completely set up before this is called.
     * @return true if successful
     */
    public boolean writeConfigFile()
    { /* writeConfigFile */
      FileWriter cfgFW;
      BufferedWriter cfgBuf;
      PrintWriter cfgPW;
      String
        newline,
        osName= System.getProperty("os.name");
      boolean isMacFlag= osName.startsWith("Mac OS");
      
      if(isMacFlag)
        newline= System.getProperty("line.separator");
      else
        newline= "\n";
      
      /* Write the field names */
      String strBuf= new String("Parameter\tValue\t" + "DataType\tComments" + 
                                newline);
      
      /* Write the variable part of the file */
      /* Array sizes - Geometry */
      strBuf= strBuf.concat("MAX_FIELDS\t"+maxFields+"\t"+
                            "int\t# replicate grids/array" + newline);
      strBuf= strBuf.concat("MAX_GRIDS\t"+maxGrids+"\t"+
                            "int\t# grids/field" + newline);
      strBuf= strBuf.concat("MAX_GRID_COLS\t"+maxGridCols+"\t"+
                            "int\t# columns/grid" + newline);
      strBuf= strBuf.concat("MAX_GRID_ROWS\t"+maxGridRows+"\t"+
                            "int\t# rows/grid" + newline);
      
      strBuf= strBuf.concat("NBR_CLONES\t"+maxRowsComputed+"\t"+
                            "int\tactual # clones/array" + newline);
      strBuf= strBuf.concat("NBR_SPOTS\t"+maxRowsComputed+"\t"+
                            "int\tactual # spots/array" + newline);
      
      strBuf= strBuf.concat("specifyGeometryByNbrSpots\t"+
                            specifyGeometryByNbrSpotsFlag+"\t"+
                            "int\tspecify pseudoarray geometry by # spots" + newline);
      
      strBuf= strBuf.concat("specifyByGridGeometry\t"+specifyByGridGeometryFlag+
                            "\tint\tspecify Grid geometry using XXXX_LAYOUT parameters" +
                            newline);
      
      /* Array layout */
      strBuf= strBuf.concat("FIELD_LAYOUT\t"+fieldLayout+"\t"+
                            "String\tlayout fields are LtoR or TtoB [Future]" + newline);
      strBuf= strBuf.concat("GRID_LAYOUT\t"+gridLayout+"\t"+
                            "String\tlayout grids are LtoR or TtoB [Future]"+ newline);
      strBuf= strBuf.concat("GRID_PER_ROW\t"+gridsPerRow+"\t"+
                            "int\t# layout grids per row in each field [Future]" + newline);
      strBuf= strBuf.concat("FIELDS_ARE_NUMBERED\t"+fieldsAreNumbered+"\t"+
                            "boolean\tContains field number else just cycles in file [Future]" + newline);
      
      /* Pseudo microarray image canvas size */
      strBuf= strBuf.concat("CanvasHorSize\t"+canvasHSize+"\t"+
                            "int\tpixel size of microarray image " + newline);
      strBuf= strBuf.concat("CanvasVertSize\t1"+canvasVSize+"\t"+
                            "int\tpixel size of microarray image " + newline);
      
      /* How XY coordinates are handled */
      strBuf= strBuf.concat("reuseXYcoords\t"+reuseXYcoordsFlag+"\t"+
                            "boolean\treuse XY coords from first probe" + newline);
      strBuf= strBuf.concat("usePseudoXYcoords\t"+usePseudoXYcoordsFlag+"\t"+
                            "boolean\tuse pseudo XY coord image - no XY data" + newline);
      strBuf= strBuf.concat("swapRowsColumns\t"+swapRowsColsFlag+"\t"+
                            "boolean\tflip array rows and columns" + newline);
      
      strBuf= strBuf.concat("noMsgReporting\tTRUE\t"+
                            "boolean\tno incremental LOADING reports for applet" + newline);
      
      //strBuf= strBuf.concat("maxPreloadImages\t"+nQuantFiles+"\t"+
      // 	            "int\tmax # sample HPs to start with unless overide");
      
      /* Additional DB file names */
      strBuf= strBuf.concat("gipoFile\t"+gipoName+"\t"+
                            "File\tname of GIPO file from Cvt2Mae" + newline);
      strBuf= strBuf.concat("samplesDBfile\t"+samplesName+"\t"+
                            "File\tname of Samples DB file from Cvt2Mae" + newline);
      
      /* Database names */
      strBuf= strBuf.concat("dataBase\t"+dirName+" DB\t"+
                            "String\tdefault name of project database" + newline);
      strBuf= strBuf.concat("dbSubset\t"+dbSubset+"\t"+
                            "String\tdefault database subset name" + newline);
      strBuf= strBuf.concat("maAnalysisProgram\t"+maAnalysisProg+"\t"+
      "String\tname of quantitation program" + newline);
      
      /* Names of special genes and other names */
      if(calibDNAname.length()>0)
        strBuf= strBuf.concat("calibDNAname\t"+calibDNAname+"\t"+
                               "String\t(opt) name of 'Calibration DNA' - if any" + newline);
      if(yourPlateName.length()>0)
        strBuf= strBuf.concat("yourPlateName\t"+yourPlateName+"\t"+
                              "String\t(opt) name of 'researcher's clones' - if any" + newline);
      
      if(emptyWellName.length()>0)
        strBuf= strBuf.concat("emptyWellName\t"+emptyWellName+"\t"+
                              "String\t(opt) name of 'emptyWellName' - if any" + newline);
      
      strBuf= strBuf.concat("classNameX\t"+classNameX+"\t"+
                            "String\tname of HP-X sample probe set" + newline);
      strBuf= strBuf.concat("classNameY\t"+classNameY+"\t"+
                            "String\tname of HP-Y sample probe set" + newline);
      
      /* fluorescent ratio data */
      strBuf= strBuf.concat("useRatioData\t"+useRatioDataFlag+"\t"+
                           "boolean\ttreat duplicate(F1,F2) data as ratio (F1/F2) - eg. Cy3/Cy5" +
                           newline);
      if(useRatioDataFlag)
      {
        strBuf= strBuf.concat("useCy5OverCy3\t"+useCy5OverCy3Flag+"\t"+
                              "boolean\tshow ratio as (Cy5/Cy3) else (Cy3/Cy5)" + newline);
        strBuf= strBuf.concat("fluorescentLbl1\t"+fluorescentLbl1+"\t"+
                              "String\tname fluorescent dye label 1 - eg. Cy3" + newline);
        strBuf= strBuf.concat("fluorescentLbl2\t"+fluorescentLbl2+"\t"+
                              "String\tname fluorescent dye label 2- eg. Cy5" + newline);
      }
      
      strBuf= strBuf.concat("allowNegQuantDataFlag\t"+allowNegQuantDataFlag+
                            "\tboolean"+
                            "\tallow negative intensity values else clip to 0.0" + newline);
      strBuf= strBuf.concat("usePosQuantDataFlag\t"+usePosQuantDataFlag+
                            "\tboolean\tFilter out genes with intensity < 0" + newline);
      strBuf= strBuf.concat("use2ndInputChipFileFlag\t"+use2ndInputChipFileFlag+
                            "\tboolean\tData consists of paired chips (e.g. A+B)" + newline);      
      
      if(cvt.mcd.useSrcTmpFileFlag)
        strBuf= strBuf.concat("useDetValueSpotDataFlag\tTRUE\tboolean"+
        "\tuse Spot Detection Value" + newline);
      
      /* Slider thresholds */
      strBuf= strBuf.concat("SpotRadius\t"+spotRadius+"\t"+
                            "int\t(2 to 20 pixels) for PseudoArray image" + newline);
      
      strBuf= strBuf.concat("clusterDistThr\t"+clusterDistThr+"\t"+
                            "float\tdefault cluster distance slider threshold [0.0 to 1000.0]" + 
                            newline);
      strBuf= strBuf.concat("nbrOfClustersThr\t"+nbrOfClustersThr+"\t"+
                           "int\tdefault # clusters for K-means clustering slider threshold [1 to 1000]" +
                            newline);
      strBuf= strBuf.concat("pValueThr\t"+pValueThr+"\t"+
                            "float\tdefault p-value for statistical tests slider threshold [0.0:1.0]" +
                            newline);
      strBuf= strBuf.concat("spotCVthr\t"+spotCVthr+"\t"+
                            "float\tdefault spot CV value slider threshold [0.0:1.0]" +
                            newline);
      strBuf= strBuf.concat("diffThr\t"+diffThr+"\t"+
                            "float\tdefault |X-Y| difference test value slider threshold [0.0:4.0]" +
                            newline);
      strBuf= strBuf.concat("pctOKthr\t"+pctOKthr+"\t"+
                            "float\tpercent spot intensity OK threshold [0.0:100.0]" + 
                            newline);
      strBuf= strBuf.concat("maxGenesReported\t"+maxGenesToRpt+"\t"+
                            "int\tmax # of genes to report in gene Reports" + newline);
      
      
      /* Web database base URLs */
      strBuf= strBuf.concat("unigeneSpecies\t"+species+
                            "\tString\tUniGene species"+ newline);
      
      strBuf= strBuf.concat("unigeneURL\thttp://www.ncbi.nlm.nih.gov/UniGene/query.cgi?ORG="+
                            UniGeneSpeciesPrefix+"&TEXT=\t"+
                            "String\tUNIGENE by Clone_ID server base address" + 
                            newline);
      
      strBuf= strBuf.concat("IMAGE2unigeneURL\thttp://nciarray.nci.nih.gov/cgi-bin/UG_query.cgi?ORG="+
                            UniGeneSpeciesPrefix+"&CLONE=\t"+
                            "String\tlookup UNIGENE from CloneID base address" +
                            newline);
      strBuf= strBuf.concat("IMAGE2GenBankURL\thttp://nciarray.nci.nih.gov/cgi-bin/UG_query.cgi?ORG="+
                            UniGeneSpeciesPrefix+"&ACC=\t"+
                            "String\tlookup GenBank from CloneID base address" +
                            newline);
      strBuf= strBuf.concat("IMAGE2GIDURL\thttp://nciarray.nci.nih.gov/cgi-bin/UG_query.cgi?ORG="+
                            UniGeneSpeciesPrefix+"&GID=\t"+
                            "String\tlookup GenBank GID from CloneID base address" +
                            newline);
      
      strBuf= strBuf.concat("genBankCloneURL\t"+genBankCloneURL+"\t"+
                            "String\tGenBank by Clone_ID NCBI server base address" +
                            newline);
      strBuf= strBuf.concat("genBankCloneURLepilogue\t"+genBankCloneURLepilogue+"\t"+
                            "String\tQ1=1247496%5Bclin%5D' encodes 'Q1=1247496[clin]" +
                            newline);
      strBuf= strBuf.concat("dbEstURL\t"+dbEstURL+"\t"+
                            "String\tdbEst NCBI server base address" +
                            newline);
      strBuf= strBuf.concat("genBankAccURL\t"+genBankAccURL+"\t"+
                            "String\tGenBankAcc NCBI base address" +
                            newline);
      strBuf= strBuf.concat("mAdbURL\t"+mAdbURL+"\t"+
                            "String\tmAdb clone server (J.Powell) base address" + 
                            newline);
      
      strBuf= strBuf.concat("gbid2LocusLinkURL\t"+gbid2LocusLinkURL+"\t"+
                            "String\tNCBI GBID to LocusLink server base address" +
                            newline);
      strBuf= strBuf.concat("locusLinkURL\t"+locusLinkURL+"\t"+
                            "String\tNCBI LocusLink LocusID server base address" +
                            newline);
      
      strBuf= strBuf.concat("GeneCardURL\t"+geneCardURL+"\t"+
                            "String\tGeneCard DB base address" + newline);
      
      strBuf= strBuf.concat("histologyURL\t"+ histologyURL+"\t"+
                            "String\thistology DB base address" + newline);
      strBuf= strBuf.concat("modelsURL\t"+ modelsURL+"\t"+
                            "String\tmodels DB base address" + newline);
      
      /* Optional GEO Platform ID if  it exists */
      strBuf= strBuf.concat("geoPlatformID\t"+ geoPlatformID+"\t"+
                            "String\tGeo Platform ID, Gene Expression Omnibus"+ 
                            newline);
      
      /* Output Genomic menu lists. First compute set of valid
       * Genomic URLs. This only uses entrys for the data that exists.
       */
      calcGenomicMenuURLs();
      if(nGenomicMenu>0)
      { /* generate Genomic menu lists */
        for(int i=0;i<nGenomicMenu;i++)
          strBuf= strBuf.concat("GenomicMenu"+(i+1)+"\t"+genomicMenu[i]+"\t"+
                                "String\tGenomic sub menu name" + newline);
        for(int i=0;i<nGenomicMenu;i++)
          strBuf= strBuf.concat("GenomicURL"+(i+1)+"\t"+genomicURL[i]+"\t"+
                               "String\tGenomic sub menu URL base address" + 
                               newline);
        for(int i=0;i<nGenomicMenu;i++)
          strBuf= strBuf.concat("GenomicURLepilogue"+(i+1)+"\t"+
                                genomicURLepilogue[i]+"\t"+
                                "String\tGenomic sub menu URL epilogue" +
                                newline);
        for(int i=0;i<nGenomicMenu;i++)
          strBuf= strBuf.concat("GenomicIDreq"+(i+1)+"\t"+
                                genomicIDreq[i]+"\t"+
                                "String\tGenomic sub menu required Genomic ID" + 
                                newline);
      } /* generate Genomic menu lists */
      
      /* Output Help menu lists */
      for(int i=0;i<nHelpMenu;i++)
        strBuf= strBuf.concat("HelpMenu"+(i+1)+"\t"+helpMenu[i]+"\t"+
                              "String\tHelp sub menu name" + newline);
      for(int i=0;i<nHelpMenu;i++)
        strBuf= strBuf.concat("HelpURL"+(i+1)+"\t"+helpURL[i]+"\t"+
                               "String\tHelp sub menu URL base address" +
                               newline);
      
      /* Write the mapTF entries. This maps user (Table,Field) names
       * to MAExplorer (Table,Field) names.
       */
      //writeFTmappings(cfgPW);  /* write it from the fieldMap DB */
      
      /* Save edit date entry for the last line */
      strBuf= strBuf.concat("EditDate\t"+date+"\t"+
                            "String\t"+"Cvt2Mae Version: "+version+"" + newline);
      
      try
      { /* write out the derived fields */
        cfgFW= new FileWriter(configFile);
        cfgBuf= new BufferedWriter(cfgFW);
        cfgPW= new PrintWriter(cfgBuf);
        cfgPW.print(strBuf);
        
        /* Close the output files */
        cfgBuf.close();
      } /* write out the derived fields */
      
      
      /* catch IO errors */
      catch(IOException ioe)
      {
        System.out.println(" MCD-WCF - IO error, Couldn't write [" +
        configFile + "]\n");
        return(false);
      }
      
      return(true);
    } /* writeConfigFile */
    
    
    /**
     * writeFTmappings() - write the mapTF entries
     * This maps User (Table,Field) names to MAExplorer (Table,Field) names
     * if the map entries were created when the fields were analyzed.
     * [TODO] Check to make sure got all of the entries.
     * @param cfgPW PrinterWriter
     */
    private void writeFTmappings(PrintWriter cfgPW)
    { /* writeFTmappings */
      for(int i= 0;i<fm.nMap;i++)
        cfgPW.println("mapTF\t"+ fm.maeTableMap[i]+","+fm.maeFieldMap[i]+","+
                      fm.userTableMap[i]+","+fm.userFieldMap[i]+
                      "\tString\tmap User (T,F) to MAE (T,F)");
    } /* writeFTmappings */
    
    
    /**
     * checkIfRequiredParamsAreSet() - check if all required parameters are set
     * before we do the conversion. If not, put a message into the
     * status area and return false.
     * Return true if all set to convert
     * @return true if successful
     * @see CvtGUI#setEditLayoutEditing
     * @see CvtGUI#setMapEditing
     * @see FileTable
     * @see FileTable#readTableFieldsFromFile
     * @see UtilCM#logMsg
     * @see UtilCM#logMsg2
     * @see UtilCM#logMsg3
     */
    public boolean checkIfRequiredParamsAreSet()
    { /* checkIfRequiredParamsAreSet */
      boolean
        flag= true,
        hasFieldDataFlag= false;
      
      /* Setup lookup fieldName indices for input file. A field does not exist
       * if its index is -1.
       * [TODO] redo this using the readData code which handles useTokFlag[]
       * better.
       */
      dio= cvt.dio;
      if(nQuantFiles>0)
      { /* read the data Field names */
        String
          oldFieldNamesGQ[]= fm.fieldNamesGQ,
          fDataQ[],
          sampleFile= quantSrcDir[0]+quantSrcFile[0];  /* only test first file for now. */
        FileTable
          ftQ= new FileTable(sampleFile);
          fDataQ= ftQ.readTableFieldsFromFile(sampleFile, rowWithFields);
        
        if(fDataQ!=null)
        { /* get indices for field names */
          hasFieldDataFlag= true;
          int
            nQfields= fDataQ.length,
            nGQfields= nSepGIPOfieldsUsed+nQfields,
            kUsed= nQfields;
          
          if(cvt.DBUG_FLAG)
          {
            System.out.println("mcd : checkIfRequiredParamsAreSet() nQfields=" +
                                nQfields+ "nGQfields ="+ nGQfields );
          }
          
          fm.fieldNamesGQ= new String[nGQfields];         /* fields actually used */
          for(int k=0;k<nQfields;k++)
            fm.fieldNamesGQ[k]= fDataQ[k];                /* copy it */
          if(nSepGIPOfieldsUsed>0)
          { /* append required GIPO to end of fieldNamesGQ */
            for(int i=0;i<nSepGIPOfields;i++)
              if(sepGIPOfieldsUsed[i])
                fm.fieldNamesGQ[kUsed++]= sepGIPOfields[i]; /* copy it */
          }
          
          fm.nMapFieldsGQ= kUsed;
          boolean mapOK= dio.genMultIdxMapOfFieldNameData(fm.fieldNamesGQ,
                                                          fm.nMapFieldsGQ,0);
          dio.setupFieldNameIndices(); /* parses data input table into
                                        * dio.idxXXX index values */
          if(oldFieldNamesGQ!=null)
          { /* restore names if not null */
            fm.nMapFieldsGQ= oldFieldNamesGQ.length;
            fm.fieldNamesGQ= oldFieldNamesGQ;
          }
        }
      } /* read the data Field names */
      
      /*
      FieldMap fmDBUG= fm;
      DataIO dioDBUG= dio;
      */
      
      if(hasSeparateGIPOandQuantFilesFlag && separateGIPOinputFile==null)
      { /* Missing GIPO file since specified separate GIPO with checkbox */
        cvt.util.logMsg("You have not defined the separate GIPO file.",
                        Color.red);
        cvt.util.logMsg2("Press 'Browse GIPO file' to define it, then try again.",
                         Color.red);
        flag= false;
      }
      
      else if(hasSeparateGIPOandQuantFilesFlag &&
      (rowWithSepGIPOFields > rowWithSepGIPOData))
      { /* Missing GIPO file since specified separate GIPO with checkbox */
        cvt.util.logMsg("The row numbers for the separate GIPO file Field ["+
                        rowWithSepGIPOFields+"] is > Data row ["+
                        rowWithSepGIPOData+"].",  Color.red);
        cvt.util.logMsg2("Press 'Edit Layout' and edit panel 'Input file starting rows data'.",
                         Color.red);
        cvt.util.logMsg3("To correct this and then try again.",  Color.red);
        flag= false;
      }
      
      else if(hasSeparateGIPOandQuantFilesFlag && rowWithSepGIPOFields<=0)
      { /* Missing GIPO file File row since specified separate GIPO with checkbox */
        cvt.util.logMsg("The row # ["+rowWithSepGIPOFields+
                        "] for the separate GIPO file Field is not defined.",
                        Color.red);
        cvt.util.logMsg2("Press 'Edit Layout' and edit panel 'Input file starting rows data'.",
                         Color.red);
        cvt.util.logMsg3("To correct this and then try again.", Color.red);
        flag= false;
      }
      
      else if(hasSeparateGIPOandQuantFilesFlag && rowWithSepGIPOData<=0)
      { /* Missing GIPO file Data row since specified separate GIPO with checkbox */
        cvt.util.logMsg("The row # ["+rowWithSepGIPOData+
                        "] for the separate GIPO file Data is not defined.",
                        Color.red);
        cvt.util.logMsg2("Press 'Edit Layout' and edit panel 'Input file starting rows data'.",
                         Color.red);
        cvt.util.logMsg3("To correct this and then try again.", Color.red);
        flag= false;
      }
      
      else if(rowWithFields > rowWithData)
      { /* Missing Quant file Field and Data rows out of order */
        cvt.util.logMsg("The row number for the quantified data file Field ["+
                        rowWithFields+"] is > Data row ["+ rowWithData+"].",
                        Color.red);
        cvt.util.logMsg2("Press 'Edit Layout' and edit panel 'Input file starting rows data'.",
                         Color.red);
        cvt.util.logMsg3("To correct this and then try again.",  Color.red);
        flag= false;
      }
      
      else if(rowWithFields<=0)
      { /* Missing Quant data file File row value */
        cvt.util.logMsg("The row # ["+ rowWithFields+
                        "] for the quantified data file Field is not defined.",
                        Color.red);
        cvt.util.logMsg2("Press 'Edit Layout' and edit panel 'Input file starting rows data'.",
                         Color.red);
        cvt.util.logMsg3("To correct this and then try again.", Color.red);
        flag= false;
      }
      
      else if(rowWithData<=0)
      { /* Missing Quant data file Data row value */
        cvt.util.logMsg("The row # ["+ rowWithData+"] for the quantified data file Data is not defined.",
                        Color.red);
        cvt.util.logMsg2("Press 'Edit Layout' and edit panel 'Input file starting rows data'.",
                         Color.red);
        cvt.util.logMsg3("To correct this and then try again.", Color.red);
        flag= false;
      }
      
      else if(maxFields<=0 || maxGrids<=0 || maxGridCols<=0 || maxGridRows<=0)
      { /* bad MCD (F,G,R,C) */
        cvt.util.logMsg("You have not defined # (Fields,Grids,Rows,Cols).",
                        Color.red);
        cvt.util.logMsg2("Go 'Edit Layout:Grid geometry data' to define it",
                         Color.red);
        cvt.util.logMsg3("in 'Grid geometry data'.", Color.black);
        flag= false;
      }
      
      else if(hasFieldDataFlag)
      { /* check for consistent set of DataIO indices */
        if((dio.idxGrid==-1 || dio.idxGridCol==-1 ||
            dio.idxGridRow==-1) && dio.idxNAME_GRC==-1 &&
            dio.idxLocation==-1)
        { /* bad Data (F,G,R,C) */
          cvt.util.logMsg("You have not defined the field map for (Fields,Grids,Rows,Cols).",
                          Color.red);
          cvt.util.logMsg2("You had selected explicit layout in 'Edit Layout:Ratio fluorescence data.",
                           Color.red);
          cvt.util.logMsg3("Use 'Assign GIPO fields' & 'Assign Quant fields' to map them.",
                           Color.red);
          flag= false;
        }
        
        else if(!useRatioDataFlag && dio.idxRawIntensity==-1)
        { /* bad Raw Intensity data */
          cvt.util.logMsg("You have not assigned RawIntensity.", Color.red);
          cvt.util.logMsg2("Use 'Assign Quant fields' to map it.", Color.red);
          cvt.util.logMsg3("", Color.black);
          flag= false;
        }
        
        else if(useRatioDataFlag && dio.idxRawIntensity1==-1 &&
                dio.idxRawIntensity2==-1)
        { /* bad Cy3,Cy5 Raw Intensity data */
          cvt.util.logMsg("You have not assigned (Cy3, Cy5) intensities.",
                          Color.red);
          cvt.util.logMsg2("Use 'Assign Quant fields' to map it.",  Color.red);
          cvt.util.logMsg3("", Color.black);
          flag= false;
        }
        
        else if(!useRatioDataFlag && hasBkgrdDataFlag && dio.idxRawBackground==-1)
        { /* bad Raw backgroundIntensity data */
          cvt.util.logMsg("You have not assigned Background intensity.",
                          Color.red);
          cvt.util.logMsg2("You had selected Background data in 'Edit Layout:Ratio fluorescence data.",
                           Color.red);
          cvt.util.logMsg3("Use 'Assign Quant fields' to map it.", Color.red);
          flag= false;
        }
        
        else if(useRatioDataFlag && hasBkgrdDataFlag &&
               (dio.idxRawBackground==-1 && dio.idxRawBackground1==-1))
        { /* bad Cy3,Cy5 Raw backgroundIntensity data */
          cvt.util.logMsg("You have not assigned Cy3, Cy5) background intensities.",
                          Color.red);
          cvt.util.logMsg2("You had selected Background data in 'Edit Layout:Ratio fluorescence data.",
                           Color.red);
          cvt.util.logMsg3("Use 'Assign Quant fields' to map it.", Color.red);
          flag= false;
        }
        
        else if(hasQuantXYcoordsFlag && (dio.idxX==-1 || dio.idxY==-1))
        { /* bad  XY data */
          cvt.util.logMsg("You have not assigned (X,Y) pixel coordinates.",
                          Color.red);
          cvt.util.logMsg2("You had selected (X,Y) data in 'Edit Layout:Microarray (X,Y) ...",
                           Color.red);
          cvt.util.logMsg3("Use 'Assign Quant fields' to map it.",  Color.red);
          flag= false;
        }
        
        else if(dio.idxGeneName==-1 && dio.idxUnigene_cluster_name==-1)
        { /* bad gene name data */
          cvt.util.logMsg("You have not assigned a Gene Name.", Color.red);
          cvt.util.logMsg2("If UniGene name, use 'Edit Layout:Gene names...' to use it",
                           Color.red);
          cvt.util.logMsg3("as gene name. Use 'Assign GIPO fields' to map GeneName.",
                           Color.red);
          flag= false;
        }
        
        else if(dio.idxLocation==-1 &&
                dio.idxClone_ID==-1 && dio.idxUnigene_cluster_ID==-1 &&
                dio.idxGenBankAcc==-1 && dio.idxGenBankAcc3==-1 &&
                dio.idxGenBankAcc5==-1 && dio.idxDbEst3==-1 &&
                dio.idxDbEst5==-1 && dio.idxSwissProtID==-1 &&
                dio.idxLocusLinkID==-1)
        { /* bad gene identifiers */
          cvt.util.logMsg("You have not assigned any gene identifiers.",
                           Color.red);
          cvt.util.logMsg2("Use 'Edit Layout:Genome identifiers' to enable one or more",
                           Color.red);
          cvt.util.logMsg3(" identifiers. Then, go 'Assign GIPO fields' to map them.",
                           Color.red);
          flag= false;
        }
      } /* check for consistent set of DataIO indices */
      
      if(!flag)
      { /* backup - enable Edit Layout and Assign GIPO and Assign Quanmt */
        cvt.gui.setEditLayoutEditing(true);
        cvt.gui.setMapEditing(true);
      }
      
      return(flag);
    } /* checkIfRequiredParamsAreSet */
    
    
} /* MaeConfigData */
